# Funcation 函数


Clojure作为函数式编程语言，函数是“一等公民”，每一个程序全部都是由函数组成。Clojure的代码为树形结构，每一个函数作为一个树的节点分支出来，并且点用其他函数。

Clojure中的函数具有以下特点：

+ 可以在程序运行时的任何时刻被动态的创建加载；
+ 没有固定的命名，但是可以绑定到若干个标识符；
+ 可以以任何数据结构进行存储；
+ 可以在函数之间被传递，传递到其他函数中进行运算。

----

## 用fn定义函数

```
(fn args expression)
```
 + args：参数符号集合是一个Vector（数组）
 + expression：函数体，功能表达式。
 
  例子：定义一个函数，实现两个数相乘的功能。
  
  ```
   (fn [x y] (* x y))
  ```
  关于上面列子的说明：
  + 上面的例子实际上由fn、[x y]、(* x y)三个form组成。
  + fn调用其他两个form；
  + [x y]是参数集合，说明这个函数有两个参数：x,y；
  + (* x y)是函数体，x、y分别绑定到各自的参数。 ＊是乘法运算符，Clojure中前缀表达式。
  + 函数总会反悔表达式的求值结果，所以没有显示的“return”返回语句。

 如果只是在REPL上面输入```(fn [x y] (* x y)) ```，这个函数并没有什么用，因为没有将这个函数绑定到任何标识符上，这样并没有将函数存储在任何地方，JVM可能会立即把它当垃圾回收了，因为它没有更多的使用。
 
 通常来说，将定义的函数绑定到一个符号上，如下所示：
 
 ```
  (def add (fn [x y](+ x y)))
 ```
 现在你可以在任何你有权限的上下文使用它了。
 
 ```
  (add 3 4)
 ```
  它的原理很简单。表达式```(def add (fn [x y](+ x y)))```求出一个第一类对象函数，这个函数绑定到add上面。调用的时候，直接使用符号就可以了。
  
 ***注意:*** 将function还有另外的一种使用方式，只要将function放在一个form的第一个位置，对这个form求值的时候，function就会被执行，不管这个function是不是绑定到一个符号或者其他的东西上。举个例子：
 
 ```
 ((fn [x y] (* x y)) 3 4)
 ```
 在这个form中，```(fn [x y] (* x y))```放在form的第一个元素，求值时```(fn [x y] (* x y))```被解析为一个function，“3 4”被当作参数传递给它。跟调用一个绑定了符号的function一样。
 
 这里需要提醒一下，function与它绑定的那个符号是不能画等号的，在前面的例子，add等于``` (fn [x y](+ x y))```，只能理解为```(fn [x y](+ x y))```绑定到add这个符号上面。当它被调用时，通过解析它获得一个function然后直接调用这个函数。
 
----
 
## 用defn定义函数
 
 尽管function与他们绑定的符号并不是同一个东西，但是通过绑定和命名函数是迄今为止使用函数最常见的方法。为此，Clojure提供了一个定义函数并绑定到符号的快捷方法： defn 。 defn 的字面意思是 def 和 fn 的合并，但是更简短、方便。它还提供了一个对函数添加文档字符串的功能，可以通过文档介绍这个函数如何使用。 defn 接着往后的参数分别是：一个符号名，一个文档字符串（可选的），一个参数列表（vector），一个函数体的表达（expression）。
 
 举个例子，上面的add方法，使用defn来定义：
 
```
(defn add
	"implement two number add function"
	[x y] 
	(+ x y))
```

然后你就可以通过指定的函数名来调用该函数：

```
(add 3 4)
```
你还可以通过内置的doc函数来查看函数的文档。系统输出会打印出该函数的文档信息。使用方式为：``` (doc add)```

***提示:*** doc 函数在编程的时候是非常有用的，Clojure所有的内置函数都有很好的文档（包括所有的类库），而且在 REPL 上使用 doc 函数也是相当方便的。同样，在你自己编写函数的时候也要养成给函数添加文档的习惯，及时没有其他人回来看你的代码，因为在一两周之后它对你自己的记忆也是有很大帮助的，让你正确的记得你当时定义这个函数是做什么的。

----

## 多元函数

元数是指函数的参数可以有多少组的组数，（类似与java的方法重载，调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法，多态性。）在Clojure中也可以基于元数来定义多个预备的实现。 这里同样使用 fn 和 defn 来定义函数，只是在参数上面有一些轻微的修改。之前是传递一个参数的vector和一个函数体的表达式（expression），现在要传递多个vector/expression对用圆括号括起来。

来一个栗子：

```
(defn square-or-multiply 
         "squares a single argument, multiplies two arguments" 
        ([] 0) 
        ([x] (* x x)) 
        ([x y] (* x y))) 
```

这里定义的函数square-or-multiply有三个预定的实现。第一个的参数是一个空的vector，不传参数时被调用，返回常量0.第二个实现带了一个参数，返回该参数的平方值。第三个实现有两个参数，返回值为这两个参数的乘积。在REPL中验证：


```
user=> (square-or-multiply) 
0 
user=>(square-or-multiply 5) 
25 
user=>(square-or-multiply 5 2) 
10 
```

## 可变参数函数

经常需要一些函数的参数个数是不定的，被叫做可变参函数（variable arity）。Clojure满足了这个要求，通过定义函数时使用特殊符号& 放在参数vector里面实现。 fn 和 defn 都可以使用。 使用：定义参数vector时，只需将& 再加上一个符号名放在普通参数后面即可。函数调用时任何附加的参数都会被装在一个序列（seq，类似于list）的结构传递进去。然后这个序列将被绑定在参数列表&后面的那个符号上面。用下面的代码举个例子：

```
user=> (defn add-arg-count 
         "Returns the first argument + the number of additional arguments" 
        [first & more] 
        (+ first (count more))) 
```
count 是一个简单的内置函数，它返回一个list的长度。查看运行结果：

```
user=> (add-arg-count 5) 
5 
user=> (add-arg-count 5 5) 
6 
user=> (add-arg-count 5 5 5 5 5 5) 
10 
```
第一次的调用，只有一个参数5，它被绑定到 first 上面而且有个空的list绑定到 more 上，因为没有附加的参数，'(count more)' 返回0。所以返回值也为第一个参数的值。然而，第二、三次调用时 more 分别绑定到了'(5)'和'(5 5 5 5 5)'上，长度分别为1和5，再加上第一个参数5并返回和。 第四章讨论了list以及一些通用函数来解析和求出他们的值。他们都能对绑定了list的 more 使用。

## 匿名函数

用fn定义函数本来就很简洁，但是有时候完整输入的时候还是很麻烦的。特别是有时候只是内部声明一个函数，并没有绑定到全局变量上。 Clojure提供了一个定义函数的快捷形式，form里面有个一个阅读器宏（Reader macro）。用快捷方式定义一个函数：前面一个 # 后面跟上一个表达式，这个表达式作为function的函数体。以及直接在这个表达式里面用百分号作为function的参数。

举个例子，实现两个数相乘的匿名函数

```
(def multiply (* %1 %2))

```
%1或者%代表第一个参数，%2代表第二个参数，以此类推。这样很容易看出匿名定义是多么的简洁，特别是内部函数。

[内容参考Clojure文档汉化小组](https://code.google.com/p/clojure-doc-en2ch/wiki/Chapter_3_Controlling_Progam_flow)
